# 一、 Java 基础

## 1、概念

### 1. 面向对象的 3 大基本特征，5 大基本原则
    
1. 三大特性是：封装，继承，多态
    - 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
    - 继承，是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。
    继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
    继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
    - 多态，是指一个类实例的相同方法在不同情形有不同表现形式。
    多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

2. 五大基本原则
    - 单一职责原则 SRP(Single Responsibility Principle)
    是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。
    - 开放封闭原则 OCP(Open－Close Principle)：开放扩展，封闭修改
    一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。
    - 替换原则(the Liskov Substitution Principle LSP) 
    子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了
    - 依赖反转原则(the Dependency Inversion Principle DIP)
    具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。
    - 接口分离原则(the Interface Segregation Principle ISP) 
    模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

### 2. 面向过程、面向对象、基于对象和继承、派生、多态——[概念比较](https://www.i3geek.com/archives/580)

1. “面向对象”和“基于对象”的区别
    - “面向对象”的三大特点（封装，继承，多态）缺一不可。
    - “基于对象”是使用对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说“基于对象”没有继承的特点。而“多态”表示为父类类型的子类对象实例，没有了继承的概念也就无从谈论“多态”。

2. “面向过程”和“面向对象”的区别
    - 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；
    - 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。面向对象是以功能来划分问题，而不是步骤；

3. “继承”和“派生”的区别
    - 其实“派生”跟“继承”是一回事，只是看它们的角度不一样而已；
    - 父类 A 派生出了子类 B == 子类 B 继承了父类 A；

4. “继承”和“多态”的区别
    - 继承：子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。
    - 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。
    可以这么说：编译时看父类，运行时看子类。

### 3. interface 和 abstrat class 抽象类的意义与区别——[原文](https://www.i3geek.com/archives/1230)

1. 抽象类
    - 抽象类：利用 abstract 修饰的类；
    - 抽象方法：利用abstract修饰只有声明没有实现的方法；
    - 有抽象方法的类，必须是抽象类；
    - 抽象类可以没有抽象方法；
    - 抽象类和普通的类一样，可以拥有成员变量和普通的成员方法；
    - 不能用抽象类创建实例对象；
    - 抽象类就是为了被继承而存在的。如果定义了一个抽象类却不被继承，那是没有任何用处的。当然，在继承之后，之类必须对父类中所有没有实现的方法进行实现，除非它是被抽象类继承的；
2. 抽象类与普通类区别
    - 抽象方法必须为 public 或者 protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；
    - 抽象类不能用来创建对象；
    - 若子类继承抽象类，则子类必须实现父类的抽象方法。否则子类必须也定义为抽象类；
3. 接口
    - 接口是一种极度抽象的类型，它比抽象类更加抽象；
    - 接口中的变量会被隐式地指定为 public static final 变量（定义成其他类型，如private会报错），同时也意味着变量必须进行初始化；
    - 接口中的方法会被隐式地指定为 public abstract 方法（用其他关键字，比如private、protected、static、final等会报错）；
    - 为了解决实现该接口的子类代码重复的问题，自 Java 8 起，接口可以定义 default(实例方法) 和 static(静态方法) 类型的方法，但是着并不意味着接口就可以直接调用这些方法，还是必须通过该接口的实现类来调用这些定义在接口中的方法；
    - 当一个非抽象类实现了接口的话，必须实现全部方法。否则该类必须是抽象类，或者接口；
    - 接口与接口之间的关系是继承，并且接口支持多继承，尽管类不支持多继承；
4. 抽象类和接口比较

    语法层面上的区别：
    - 接口只能有public abstract 方法(隐式指定)，抽象类的方法类型更多，可以有普通方法；
    - 接口中的成员变量只能是public static final类型的，抽象类的变量类型更多，可以有普通变量；
    - 一个类只能继承一个抽象类，而一个类却可以实现多个接口；
    设计层面上的区别：
    - 抽象类是对事物的抽象（类的抽象），接口是对行为的抽象；
    - 抽象类是一种模板式设计，接口是一种行为规范，一种辐射式设计；

### 4. Overload(重载) 和 Override(重写) 区别

1. 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
    - 参数列表必须完全与被重写方法的相同；
    - 返回类型必须完全与被重写方法的返回类型相同；
    - 访问权限不能比父类中被重写的方法的访问权限更低，子类中的方法更加开放；
    - 父类的成员方法只能被它的子类重写；
    - 声明为final的方法不能被重写；
    - 声明为 static 的方法不能被重写，但是能够被再次声明；
    - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法；
    - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法；
    - 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常，即只能抛出原方法异常的子类异常；
    - 构造方法不能被重写；
    - 如果不能继承一个方法，则不能重写这个方法，能继承是前提；

2. Super 关键字的使用
    - 当需要在子类中调用父类的被重写方法时，要使用super关键字，相当于父类的对象实例代表，相当于父类传递到子类中的 this；

3. 重载是在一个类里面，方法名字相同，而参数不同
    - 被重载的方法必须改变参数列表(参数个数或类型不一样)，无法以返回值类型作为重载函数的区分标准；
    - 被重载的方法可以改变返回类型；
    - 被重载的方法可以改变访问修饰符；
    - 被重载的方法可以声明新的或更广的检查异常；
    - 方法能够在同一个类中或者在一个子类中被重载；

4. 区别对比

    区别点 | 重载 | 重写
    ---|---|---
    参数列表 | 必须修改 | 一定不能修改
    返回类型 | 可以修改 | 一定不能修改
    异常 | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常
    访问 | 可以修改	| 一定不能做更严格的限制（可以降低限制）

    - 方法的重写和重载是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

### 5. abstract 的 method 是否可同时是 static，是否可同时是 native，是否可同时是 synchronized

1. 都不可以，即 abstract 方法不能是 static/native/synchronized

    - static与abstract不能同时使用：用static声明方法表明这个方法在不生成类的实例时可直接被类调用，而abstract方法不能被调用，两者矛盾；
    - native可以与所有其它的java标识符连用，但是abstract除外：因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体；
    - abstract与synchronized不能同时使用：从 synchronized 的功能也可以看出，用 synchronized 的前提是该方法可以被直接调用，显然不能和 abstract 连用

### 6. Java 异常体系

1. 遇到错误至少保证这几点：
    - 向用户报告错误；
    - 保存所有的工作结果；
    - 允许用户以妥善的形式退出；

2. 基本结构

- class Throwable：
    - class Error：Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，JVM 一般会选择线程终止；
    - class Exception：Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常；
        - class RuntimeException：运行时异常，如NullPointerException、IndexOutOfBoundsException等；这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序员应该从逻辑角度尽可能避免这类异常的发生；
        - 非运行时异常：是 RuntimeException 以外的异常。语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、SQLException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常；

3. 异常的捕获和处理

- 五个关键字：try、catch、finally、throw、throws  
    - try 语句块，表示要尝试运行代码；
    - catch 语句带一个 Throwable 类型的参数；
    - finally 语句块是紧跟 catch 语句后的语句块，这个语句块总是会在方法返回前执行，而不管是否 try 语句块是否发生异常；
    - throw 关键字是用于方法体内部，用来抛出一个 Throwable 类型的异常；
    - throws 关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣一般在catch块中打印一下堆栈信息做个勉强处理；

4. Throwable类中的常用方法
    ```
    // Returns the detail message string of this throwable.
    public String getMessage() {
        return detailMessage;
    }

    // 返回抛出异常的类型
    private Throwable cause = this;
    public synchronized Throwable getCause() {
        return (cause==this ? null : cause);
    }

    // Prints this throwable and its backtrace to the standard error stream.
    public void printStackTrace() {
        printStackTrace(System.err);
    }
    public void printStackTrace(PrintStream s) {
        printStackTrace(new WrappedPrintStream(s));
    }
    ```
5. 异常处理的一般原则

    - 能处理就早处理，抛出不去还不能处理的就想法消化掉或者转换为RuntimeException处理。因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能的控制异常发生的可能； 
    - 对于检查异常，如果不能行之有效的处理，还不如转换为RuntimeException抛出。这样也让上层的代码有选择的余地――可处理也可不处理； 
    - 对于一个应用系统来说，应该有自己的一套异常处理框架，这样当异常发生时，也能得到统一的处理风格，将优雅的异常信息反馈给用户；

6. 异常的转译与异常链

- 异常转译的原理
    - 异常转译：就是将一种异常转换另一种新的异常，也许这种新的异常更能准确表达程序发生异常；
    - 异常原因：就是导致当前抛出异常的那个异常对象；
    - 几乎所有带异常原因的异常类构造方法都使用 Throwable 类型做参数，这也就为异常的转译提供了直接的支持；
    ```
    public class MyException extends RuntimeException {
        public MyException(String message, Throwable cause) {
            super(message, cause);  // 关键在此！
        }
    }
    ```
    - 异常转译是针对所有继承 Throwable 超类的类而言的，从编程的语法角度讲，其子类之间都可以相互转换；
    - 从合理性和系统设计角度考虑，异常转译可以参考：
        - Error -> Exception
        - Error -> RuntimeException
        - Exception -> RuntimeException

7. 设计一个高效合理的异常处理框架
    - 对于一个应用系统来说，发生所有异常在用户看来都是应用系统内部的异常。因此应该设计一套应用系统的异常框架，以处理系统运行过程中的所有异常；
    - 有关异常框架设计这方面公认比较好的就是Spring，Spring中的所有异常都可以用org.springframework.core.NestedRuntimeException 来表示，并且该基类继承的是RuntimeException；
    - Spring 框架很庞大，因此设计了很多 NestedRuntimeException 的子类，还有异常转换的工具；
    - 此处需要进一步探究...

### transient 关键字

    - 被加上 transient 的属性将不会被序列化；这可能是一些敏感信息
    - 只能修饰变量；
    - 静态变量不会被序列化，是否加上 transient 结果都一样，但是反序列化时如果还在同一个 JVM 中进行，那么静态变量将会看到具体值，因为 JVM 会保存它；











