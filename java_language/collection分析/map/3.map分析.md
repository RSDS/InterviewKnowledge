# Map 分析
> 介绍 Map集合、散列表和红黑树

## 〇、基础知识——散列表（hash table）
> 《算法导论》ch11 散列表

### 0. 概论
1. 散列表查找一个元素的最坏情况与链表相同，都是 Θ(n)，但是在一些合理的假设下，它的平均时间是 O(1)；
2. 散列表是普通数组概念的推广。由于普通数组可以直接寻址，使得能在O(1)时间内访问数组的任意位置；
3. 当实际存储的关键字数目比全部可能的关键字数目要小时，采用散列表就成为直接数组寻址的一种有效替代。因为散列表使用一个长度与实际存储关键数目成比例的数组来存储，并不是直接把关键字作为数组下标的，而是根据关键字计算出相应的下表；

### 1. 直接寻址表

1. 当关键字的全域 U 比较小时，直接寻址是一种简单有效的技术；
2. 构建直接寻址表
    - 假设一个动态集合的所有元素都取自于全域 U = {0,1...,m-1} 中的一个关键字，m 不是很大，且假设没有两个元素具有相同的关键字；
    - 用一个被称为直接寻址表的数组，记为 T[i],iϵU，i 对应 U 中的一个关键字（决定了直接寻址表将会很大）；
    - 这样就有如下O(1)操作：
        - 查找：T[k]
        - 插入：T[x.k] = x
        - 删除：T[x.k] = NIL

### 2. 散列表

1. 直接寻址表的缺点：如果全域 U 很大，则对存储要求较大，而且很可能实际存储的关键字集合K相对于 U 很小，造成 T 的空间浪费；
2. 我们需要将存储空间的需求降低至 Θ(|K|)，但是平均查找时间保持在 O(1)；
3. 在直接寻址下，具有k关键字的元素被存放在 T[k] 中；而在散列方式下，将该元素存放在 h(k) 中，即利用散列函数h，由关键字k计算出位置，这里的函数h将全域 U 映射到 T[i] 上：<i>h:U->{0,1...,m-1}</i>
- 冲突：当两个关键字映射到同一个，既有 h(k1) = h(k2)；
    - 理想的办法是选择适合的hash函数，以避免冲突，但是函数是确定的，总会有冲突出现；
    - 链接法：将冲突的元素链接成一个链表
    - 开放寻址法，后面介绍

4. 通过链接法解决冲突
- 插入操作的最坏情况是 O(1)；
- 删除操作：当使用双向链接时，O(1)；使用单向链接时，与查找元素相同 O(n)；因为删除操作时会传入元素值，所以无需查找（需要进一步研究？？？）




## 一、Map 介绍


























